---
layout: default
title: Apps
parent: The Key Components
grand_parent: pages.understanding_firefly
nav_order: 2
---

# Apps
{: .no_toc }

---

## Application features

Rapidly accelerating development is a key requirement of any Supernode.

The business logic APIs, web and mobile user experiences for Web3 applications need to be just as rich
and feature-full as the Web 2.0 / centralized applications.

That means developers skilled in these application layers, must have the tools they need.

Capabilities fitting their application development toolchain, and optimized to their skillset.

### API Gateway

Modern APIs that:

- Are fast and efficient
- Have rich query support
- Give deterministic outcomes and clear instruction for safe use
- Integrate with your security frameworks like OAuth 2.0 / OpenID Connect single sign-on
- Provide Open API 3 / Swagger definitions
- Come with code SDKs, with rich type information
- Conform as closely as possible to the principles of REST
- Do not pretend to be RESTful in cases when it is impossible to be

### Event Streams

The reality is that the only programming paradigm that works for a decentralized solutions,
is an event-driven one.

All blockchain technologies are for this reason event-driven programming interfaces at their core.

In an overall solution, those on-chain events must be coordinated with off-chain private
data transfers, and existing core-systems / human workflows.

This means great event support is a must:

- Convenient WebSocket APIs that work for your microservices development stack
- Support for Webhooks to integrated serverless functions
- Integration with your core enterprise message queue (MQ) or enterprise service bus (ESB)
- At-least-once delivery assurance, with simple instructions at the application layer

### API Generation

The blockchain is going to be at the heart of your Web3 project. While usually small in overall surface
area compared to the lines of code in the traditional application tiers, this kernel of
mission-critical code is what makes your solution transformational compared to a centralized / Web 2.0 solution.

Whether the smart contract is hand crafted for your project, an existing contract on a public blockchain,
or a built-in pattern of a framework like FireFly - it must be interacted with correctly.

So there can be no room for misinterpretation in the hand-off between the blockchain
Smart Contract specialist, familiar with EVM contracts in Solidity/Vyper, Fabric chaincode
(or maybe even raw block transition logic in Rust or Go), and the backend/full-stack
application developer / core-system integrator.

Well documented APIs are the modern norm for this, and it is no different for blockchain. This means:

- Generating the interface for methods and events on your smart contract
- Providing robust transaction submission, and event streaming
- Publishing the API, version, and location, of your smart contracts to the network

