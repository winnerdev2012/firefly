// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package batchingmocks

import (
	context "context"

	batching "github.com/kaleido-io/firefly/internal/batching"

	fftypes "github.com/kaleido-io/firefly/internal/fftypes"

	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// BatchManager is an autogenerated mock type for the BatchManager type
type BatchManager struct {
	mock.Mock
}

// Close provides a mock function with given fields:
func (_m *BatchManager) Close() {
	_m.Called()
}

// DispatchMessage provides a mock function with given fields: ctx, msg, data
func (_m *BatchManager) DispatchMessage(ctx context.Context, msg *fftypes.Message, data ...*fftypes.Data) (*uuid.UUID, error) {
	_va := make([]interface{}, len(data))
	for _i := range data {
		_va[_i] = data[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, msg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *uuid.UUID
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Message, ...*fftypes.Data) *uuid.UUID); ok {
		r0 = rf(ctx, msg, data...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uuid.UUID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Message, ...*fftypes.Data) error); ok {
		r1 = rf(ctx, msg, data...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterDispatcher provides a mock function with given fields: batchType, handler, batchOptions
func (_m *BatchManager) RegisterDispatcher(batchType fftypes.MessageType, handler batching.DispatchHandler, batchOptions batching.BatchOptions) {
	_m.Called(batchType, handler, batchOptions)
}
